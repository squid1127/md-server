<!-- md-server - Interactive Markdown Editor -->
{% extends 'base.html' %}

<!-- Header Content -->
{% block head %}
<link rel="stylesheet" href="/static/editor.css" />
{% endblock %}

<!-- Markdown Content -->
{% block content %}
<section class="content editor">
  <div class="editor-header">
    <h2>Markdown Editor</h2>
  </div>
  <div class="editor-container">
    <div class="editor-input">
      <textarea
        id="markdown-input"
        placeholder="Enter your markdown here..."
      ></textarea>
    </div>
    <div class="editor-preview">
      <div id="markdown-preview" class="markdown-body markdown-preview"></div>
    </div>
  </div>
  <!-- <div class="test-container">
    <div class="test-box">Test Box</div>
    <div class="test-box">Test Box 2</div>
  </div> -->
</section>
{% endblock %}

<!-- Header Extra Content -->
{% block header_right %}
<button
  class="header-btn"
  id="open-preview-btn"
  title="Open Preview in New Tab"
>
  <span class="material-symbols-outlined">open_in_new</span>
</button>
<button
  class="header-btn copy-btn"
  id="copy-markdown-btn"
  title="Copy markdown source"
>
  <span class="material-symbols-outlined">content_copy</span>
</button>
<button class="header-btn user-btn" id="user-btn" title="User Menu">
  <span class="material-symbols-outlined">account_circle</span>
</button>
{% endblock %}

<!-- Scripts -->
{% block scripts %}
<script>
  const input = document.getElementById("markdown-input");
  const preview = document.getElementById("markdown-preview");
  const openPreviewBtn = document.getElementById("open-preview-btn");
  const copyBtn = document.getElementById("copy-markdown-btn");
  const userBtn = document.getElementById("user-btn");

  let debounceTimeout;

  // Render markdown via API
  async function renderMarkdown() {
    const md = input.value;
    try {
      if (!md.trim()) {
        preview.innerHTML = "<p><em>No markdown content to display.</em></p>";
        return;
      }
      const response = await fetch("/render-embed", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ md }),
      });
      if (!response.ok) {
        throw new Error("Failed to render markdown");
      }
      const html = await response.text();
      preview.innerHTML = html;
      // Re-run syntax highlighting
      Prism.highlightAll();
    } catch (error) {
      preview.innerHTML = `<p style="color: red;">Error: ${error.message}</p>`;
    }
  }

  // Handle Tab key for indentation
  input.addEventListener("keydown", (e) => {
    if (e.key === "Tab") {
      e.preventDefault(); // Prevent default tab behavior

      const start = input.selectionStart;
      const end = input.selectionEnd;
      const value = input.value;

      if (e.shiftKey) {
        // Shift+Tab: Remove indentation
        const lineStart = value.lastIndexOf("\n", start - 1) + 1;
        const lineEnd = value.indexOf("\n", end);
        const actualLineEnd = lineEnd === -1 ? value.length : lineEnd;

        const lines = value.substring(lineStart, actualLineEnd).split("\n");
        const newLines = lines.map((line) => {
          // Remove up to 2 spaces or 1 tab from the beginning
          if (line.startsWith("\t")) {
            return line.substring(1);
          } else if (line.startsWith("  ")) {
            return line.substring(2);
          } else if (line.startsWith(" ")) {
            return line.substring(1);
          }
          return line;
        });

        const newText =
          value.substring(0, lineStart) +
          newLines.join("\n") +
          value.substring(actualLineEnd);
        input.value = newText;

        // Restore cursor position
        const lengthDiff = newText.length - value.length;
        input.selectionStart = Math.max(lineStart, start + lengthDiff);
        input.selectionEnd = Math.max(lineStart, end + lengthDiff);
      } else {
        // Tab: Add indentation
        if (start === end) {
          // No selection, just insert tab
          const tabChar = "  "; // Use 2 spaces instead of \t for better web compatibility
          input.value =
            value.substring(0, start) + tabChar + value.substring(end);
          input.selectionStart = input.selectionEnd = start + tabChar.length;
        } else {
          // Selection exists, indent all selected lines
          const lineStart = value.lastIndexOf("\n", start - 1) + 1;
          const lineEnd = value.indexOf("\n", end);
          const actualLineEnd = lineEnd === -1 ? value.length : lineEnd;

          const lines = value.substring(lineStart, actualLineEnd).split("\n");
          const newLines = lines.map((line) => "  " + line); // Add 2 spaces to each line

          const newText =
            value.substring(0, lineStart) +
            newLines.join("\n") +
            value.substring(actualLineEnd);
          input.value = newText;

          // Restore selection
          const lengthDiff = newText.length - value.length;
          input.selectionStart = start + 2; // Account for added indentation
          input.selectionEnd = end + lengthDiff;
        }
      }

      // Trigger render after tab handling
      clearTimeout(debounceTimeout);
      debounceTimeout = setTimeout(renderMarkdown, 300);
    }
  });

  // Render on input with debounce
  input.addEventListener("input", () => {
    clearTimeout(debounceTimeout);
    debounceTimeout = setTimeout(renderMarkdown, 300); // 300ms delay
  });

  // [Btn] Open preview in new tab
  openPreviewBtn.addEventListener("click", () => {
    // Use /render endpoint to render full page
    const md = encodeURIComponent(input.value);
    const url = `/render?md=${md}&title=Markdown%20Preview`;

    window.open(url, "_blank");
  });

  // [Btn] Copy markdown to clipboard
  async function copyToClipboard() {
    try {
      const md = input.value;
      await navigator.clipboard.writeText(md);

      // Visual feedback
      const originalText = copyBtn.innerHTML;
      copyBtn.innerHTML =
        '<span class="material-symbols-outlined">check</span>';
      copyBtn.classList.add("copied");

      setTimeout(() => {
        copyBtn.innerHTML = originalText;
        copyBtn.classList.remove("copied");
      }, 2000);
    } catch (error) {
      console.error("Failed to copy markdown:", error);

      // Error feedback
      const originalText = copyBtn.innerHTML;
      copyBtn.innerHTML =
        '<span class="material-symbols-outlined">error</span>';
      copyBtn.classList.add("error");

      setTimeout(() => {
        copyBtn.innerHTML = originalText;
        copyBtn.classList.remove("error");
      }, 2000);
    }
  }
  copyBtn.addEventListener("click", copyToClipboard);

  // Check if user is authenticated
  async function checkAuth() {
    let response;
    try {
      response = await fetch("/dash/status");
    } catch (error) {
      console.warn(
        "User not authenticated: Got error when checking auth status: ",
        error,
      );
      return null;
    }
    if (response.status === 200) {
      console.log("Auth check passed");
      return response.json();
    } else {
      console.log("User not authenticated: Status ", response.status);
      return null;
    }
  }

  // Show user options if authenticated
  function showUserOptions() {
    console.log("Showing user options");
    userBtn.style.display = "inline-flex";
    userBtn.onclick = () => {
      window.location.href = "/dash/";
    };
  }

  // Initial render
  renderMarkdown();

  // Stop page from closing if unsaved changes
  window.addEventListener("beforeunload", (e) => {
    if (input.value.trim()) {
      e.preventDefault();
      e.returnValue =
        "Are you sure you want to leave? You may have unsaved changes."; // Chrome requires returnValue to be set
    }
  });

  // Check auth status on load
  window.addEventListener("load", () => {
    checkAuth().then((user) => {
      if (user) {
        showUserOptions();
      }
    });
  });

  // Command Palette
  window.addEventListener("load", () => {
    if (window.cmdPalette) {
      window.cmdPalette.registerCommands([
        {
          name: "Copy Markdown Source",
          action: copyToClipboard,
          icon: "content_copy",
          group: "Editor",
        },
        {
          name: "Open Preview in New Tab",
          action: () => openPreviewBtn.click(),
          icon: "open_in_new",
          group: "Editor",
        },
      ]);
    } else {
      console.warn("Command Palette not loaded");
    }
  });
</script>
{% endblock %}
